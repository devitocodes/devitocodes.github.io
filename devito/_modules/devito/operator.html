

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>devito.operator &mdash; Devito v3.4</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/devito_logo.png"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href="../../_static/devito_style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Devito v3.4
          

          
            
            <img src="../../_static/devito_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userapi.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../compiler.html">The Devito Compiler</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Devito v3.4</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>devito.operator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for devito.operator</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">ceil</span>

<span class="kn">from</span> <span class="nn">cached_property</span> <span class="k">import</span> <span class="n">cached_property</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="kn">from</span> <span class="nn">devito.dle</span> <span class="k">import</span> <span class="n">transform</span>
<span class="kn">from</span> <span class="nn">devito.equation</span> <span class="k">import</span> <span class="n">Eq</span>
<span class="kn">from</span> <span class="nn">devito.exceptions</span> <span class="k">import</span> <span class="n">InvalidOperator</span>
<span class="kn">from</span> <span class="nn">devito.logger</span> <span class="k">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">perf</span><span class="p">,</span> <span class="n">warning</span><span class="p">,</span> <span class="n">is_log_enabled_for</span>
<span class="kn">from</span> <span class="nn">devito.ir.equations</span> <span class="k">import</span> <span class="n">LoweredEq</span>
<span class="kn">from</span> <span class="nn">devito.ir.clusters</span> <span class="k">import</span> <span class="n">clusterize</span>
<span class="kn">from</span> <span class="nn">devito.ir.iet</span> <span class="k">import</span> <span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">MetaCall</span><span class="p">,</span> <span class="n">iet_build</span><span class="p">,</span> <span class="n">iet_insert_decls</span><span class="p">,</span>
                           <span class="n">iet_insert_casts</span><span class="p">,</span> <span class="n">derive_parameters</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">devito.ir.stree</span> <span class="k">import</span> <span class="n">st_build</span>
<span class="kn">from</span> <span class="nn">devito.mpi</span> <span class="k">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">devito.parameters</span> <span class="k">import</span> <span class="n">configuration</span>
<span class="kn">from</span> <span class="nn">devito.profiling</span> <span class="k">import</span> <span class="n">create_profile</span>
<span class="kn">from</span> <span class="nn">devito.symbolics</span> <span class="k">import</span> <span class="n">indexify</span>
<span class="kn">from</span> <span class="nn">devito.tools</span> <span class="k">import</span> <span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Signer</span><span class="p">,</span> <span class="n">ReducerMap</span><span class="p">,</span> <span class="n">as_tuple</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">filter_ordered</span><span class="p">,</span>
                          <span class="n">filter_sorted</span><span class="p">,</span> <span class="n">split</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">devito.types</span> <span class="k">import</span> <span class="n">Dimension</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Operator&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../operator.html#devito.operator.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="n">Callable</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate, JIT-compile and run C code starting from an ordered sequence</span>
<span class="sd">    of symbolic expressions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expressions : expr-like or list or expr-like</span>
<span class="sd">        The (list of) expression(s) defining the Operator computation.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        * name : str</span>
<span class="sd">            Name of the Operator, defaults to &quot;Kernel&quot;.</span>
<span class="sd">        * subs : dict</span>
<span class="sd">            Symbolic substitutions to be applied to ``expressions``.</span>
<span class="sd">        * dse : str</span>
<span class="sd">            Aggressiveness of the Devito Symbolic Engine for flop</span>
<span class="sd">            optimization. Defaults to ``configuration[&#39;dse&#39;]``.</span>
<span class="sd">        * dle : str</span>
<span class="sd">            Aggressiveness of the Devito Loop Engine for loop-level</span>
<span class="sd">            optimization. Defaults to ``configuration[&#39;dle&#39;]``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following Operator implements a trivial time-marching method that</span>
<span class="sd">    adds 1 to every grid point in ``u`` at every timestep.</span>

<span class="sd">    &gt;&gt;&gt; from devito import Eq, Grid, TimeFunction, Operator</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(shape=(4, 4))</span>
<span class="sd">    &gt;&gt;&gt; u = TimeFunction(name=&#39;u&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; op = Operator(Eq(u.forward, u + 1))</span>

<span class="sd">    Multiple expressions can be supplied, and there is no limit to the number of</span>
<span class="sd">    expressions in an Operator.</span>

<span class="sd">    &gt;&gt;&gt; v = TimeFunction(name=&#39;v&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; op = Operator([Eq(u.forward, u + 1),</span>
<span class="sd">    ...                Eq(v.forward, v + 1)])</span>

<span class="sd">    Simple boundary conditions can be imposed easily exploiting the &quot;indexed</span>
<span class="sd">    notation&quot; for Functions/TimeFunctions.</span>

<span class="sd">    &gt;&gt;&gt; t = grid.stepping_dim</span>
<span class="sd">    &gt;&gt;&gt; x, y = grid.dimensions</span>
<span class="sd">    &gt;&gt;&gt; op = Operator([Eq(u.forward, u + 1),</span>
<span class="sd">    ...                Eq(u[t+1, x, 0], 0),</span>
<span class="sd">    ...                Eq(u[t+1, x, 2], 0),</span>
<span class="sd">    ...                Eq(u[t+1, 0, y], 0),</span>
<span class="sd">    ...                Eq(u[t+1, 2, y], 0)])</span>

<span class="sd">    A semantically equivalent computation can be expressed exploiting SubDomains.</span>

<span class="sd">    &gt;&gt;&gt; u.data[:] = 0</span>
<span class="sd">    &gt;&gt;&gt; op = Operator(Eq(u.forward, u + 1, subdomain=grid.interior))</span>

<span class="sd">    By specifying a SubDomain, the Operator constrains the execution of an expression to</span>
<span class="sd">    a certain sub-region within the computational domain. Ad-hoc SubDomains can also be</span>
<span class="sd">    created in application code -- refer to the SubDomain documentation for more info.</span>

<span class="sd">    Advanced boundary conditions can be expressed leveraging `SubDomain` and</span>
<span class="sd">    `SubDimension`.</span>

<span class="sd">    Tensor contractions are supported, but with one caveat: in case of MPI execution, any</span>
<span class="sd">    global reductions along an MPI-distributed Dimension should be handled explicitly in</span>
<span class="sd">    user code. The following example shows how to implement the matrix-vector</span>
<span class="sd">    multiplication ``Av = b`` (inducing a reduction along ``y``).</span>

<span class="sd">    &gt;&gt;&gt; from devito import Inc, Function</span>
<span class="sd">    &gt;&gt;&gt; A = Function(name=&#39;A&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; v = Function(name=&#39;v&#39;, shape=(3,), dimensions=(y,))</span>
<span class="sd">    &gt;&gt;&gt; b = Function(name=&#39;b&#39;, shape=(3,), dimensions=(x,))</span>
<span class="sd">    &gt;&gt;&gt; op = Operator(Inc(b, A*v))</span>

<span class="sd">    Dense and sparse computation may be present within the same Operator. In the</span>
<span class="sd">    following example, interpolation is used to approximate the value of four</span>
<span class="sd">    sparse points placed at the center of the four quadrants at the grid corners.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from devito import SparseFunction</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(shape=(4, 4), extent=(3.0, 3.0))</span>
<span class="sd">    &gt;&gt;&gt; f = Function(name=&#39;f&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; coordinates = np.array([(0.5, 0.5), (0.5, 2.5), (2.5, 0.5), (2.5, 2.5)])</span>
<span class="sd">    &gt;&gt;&gt; sf = SparseFunction(name=&#39;sf&#39;, grid=grid, npoint=4, coordinates=coordinates)</span>
<span class="sd">    &gt;&gt;&gt; op = Operator([Eq(f, f + 1)] + sf.interpolate(f))</span>

<span class="sd">    The iteration direction is automatically detected by the Devito compiler. Below,</span>
<span class="sd">    the Operator runs from ``time_M`` (maximum point in the time dimension) down to</span>
<span class="sd">    ``time_m`` (minimum point in the time dimension), as opposed to all of the examples</span>
<span class="sd">    seen so far, in which the execution along time proceeds from ``time_m`` to ``time_M``</span>
<span class="sd">    through unit-step increments.</span>

<span class="sd">    &gt;&gt;&gt; op = Operator(Eq(u.backward, u + 1))</span>

<span class="sd">    Loop-level optimisations, including SIMD vectorisation and OpenMP parallelism, are</span>
<span class="sd">    automatically discovered and handled by the Devito compiler. For more information,</span>
<span class="sd">    refer to the relevant documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_default_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;#define _POSIX_C_SOURCE 200809L&#39;</span><span class="p">]</span>
    <span class="n">_default_includes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stdlib.h&#39;</span><span class="p">,</span> <span class="s1">&#39;math.h&#39;</span><span class="p">,</span> <span class="s1">&#39;sys/time.h&#39;</span><span class="p">]</span>
    <span class="n">_default_globals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="n">as_tuple</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>

        <span class="c1"># Input check</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidOperator</span><span class="p">(</span><span class="s2">&quot;Only `devito.Eq` expressions are allowed.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;Kernel&quot;</span><span class="p">)</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subs&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">dse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dse&quot;</span><span class="p">,</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;dse&#39;</span><span class="p">])</span>

        <span class="c1"># Header files, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_headers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_includes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_includes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_globals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_globals</span><span class="p">)</span>

        <span class="c1"># Required for compilation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;compiler&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cfunction</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># References to local or external routines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># Internal state. May be used to store information about previous runs,</span>
        <span class="c1"># autotuning reports, etc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Form and gather any required implicit expressions</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_implicit</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>

        <span class="c1"># Expression lowering: evaluation of derivatives, flatten vectorial equations,</span>
        <span class="c1"># indexification, substitution rules, specialization</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">evaluate</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">]</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expressions</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">_flatten</span><span class="p">]</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">]</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_substitutions</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">subs</span><span class="p">)</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specialize_exprs</span><span class="p">(</span><span class="n">expressions</span><span class="p">)</span>

        <span class="c1"># Expression analysis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="n">filter_sorted</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">reads</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">writes</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output</span> <span class="o">=</span> <span class="n">filter_sorted</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">writes</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span> <span class="o">=</span> <span class="n">filter_sorted</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">))</span>

        <span class="c1"># Group expressions based on their iteration space and data dependences</span>
        <span class="c1"># Several optimizations are applied (fusion, lifting, flop reduction via DSE, ...)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusterize</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">dse_mode</span><span class="o">=</span><span class="n">set_dse_mode</span><span class="p">(</span><span class="n">dse</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dspace</span> <span class="o">=</span> <span class="n">clusters</span><span class="o">.</span><span class="n">meta</span>

        <span class="c1"># Lower Clusters to a Schedule tree</span>
        <span class="n">stree</span> <span class="o">=</span> <span class="n">st_build</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>

        <span class="c1"># Lower Schedule tree to an Iteration/Expression tree (IET)</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="n">iet_build</span><span class="p">(</span><span class="n">stree</span><span class="p">)</span>
        <span class="n">iet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_sections</span><span class="p">(</span><span class="n">iet</span><span class="p">)</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specialize_iet</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Derive all Operator parameters based on the IET</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">derive_parameters</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Finalization: introduce declarations, type casts, etc</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">iet</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="p">())</span>

    <span class="c1"># Read-only fields exposed to the outside world</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_output</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Input</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">filter_ordered</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Object</span><span class="p">)</span>

    <span class="c1"># Compilation</span>

    <span class="k">def</span> <span class="nf">_initialize_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;optimizations&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">configuration</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;dse&#39;</span><span class="p">,</span> <span class="s1">&#39;dle&#39;</span><span class="p">)}}</span>

    <span class="k">def</span> <span class="nf">_add_implicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and add any associated implicit expressions.</span>

<span class="sd">        Implicit expressions are those not explicitly defined by the user</span>
<span class="sd">        but instead are requisites of some specified functionality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">root</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">)]</span>
                    <span class="n">sub_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">root</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">dimensions</span><span class="p">]</span>
                    <span class="n">sub_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">implicit_dimension</span><span class="p">)</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">sub_dims</span><span class="p">)]</span>
                    <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">implicit_dimension</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">subdomain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="n">processed</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">implicit_dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                          <span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">_create_implicit_exprs</span><span class="p">()])</span>
                        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="p">)</span>
                    <span class="n">dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                    <span class="n">new_e</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">subdomain</span><span class="o">=</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="p">,</span> <span class="n">implicit_dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
                    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_e</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">processed</span>

    <span class="k">def</span> <span class="nf">_apply_substitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">subs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``expressions`` by: ::</span>

<span class="sd">            * Applying any user-provided symbolic substitution;</span>
<span class="sd">            * Replacing Dimensions with SubDimensions based on expression SubDomains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="p">:</span>
                <span class="n">mapper</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">subdomain</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">)</span>
            <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">mapper</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">processed</span>

    <span class="k">def</span> <span class="nf">_specialize_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform ``expressions`` into a backend-specific representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">LoweredEq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_profile_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instrument the IET for C-level profiling.&quot;&quot;&quot;</span>
        <span class="n">profiler</span> <span class="o">=</span> <span class="n">create_profile</span><span class="p">(</span><span class="s1">&#39;timers&#39;</span><span class="p">)</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="n">profiler</span><span class="o">.</span><span class="n">instrument</span><span class="p">(</span><span class="n">iet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_includes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">profiler</span><span class="o">.</span><span class="n">_default_includes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="p">:</span> <span class="n">MetaCall</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">profiler</span><span class="o">.</span><span class="n">_ext_calls</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">iet</span><span class="p">,</span> <span class="n">profiler</span>

    <span class="k">def</span> <span class="nf">_specialize_iet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iet</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the IET into a backend-specific representation, such as code</span>
<span class="sd">        to be executed on a GPU or through a lower-level system (e.g., YASK).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dle&quot;</span><span class="p">,</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;dle&#39;</span><span class="p">])</span>

        <span class="c1"># Apply the Devito Loop Engine (DLE) for loop optimization</span>
        <span class="n">iet</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="o">*</span><span class="n">set_dle_mode</span><span class="p">(</span><span class="n">dle</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">MetaCall</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">efuncs</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_includes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">includes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">iet</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iet</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="n">iet_insert_decls</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
        <span class="n">iet</span> <span class="o">=</span> <span class="n">iet_insert_casts</span><span class="p">(</span><span class="n">iet</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="c1"># Now do the same to each ElementalFunction</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="n">body</span> <span class="o">=</span> <span class="n">iet_insert_decls</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
                <span class="n">body</span> <span class="o">=</span> <span class="n">iet_insert_casts</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">MetaCall</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">_rebuild</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">iet</span>

    <span class="c1"># Arguments processing</span>

    <span class="k">def</span> <span class="nf">_prepare_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process runtime arguments passed to ``.apply()` and derive</span>
<span class="sd">        default values for any remaining arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overrides</span><span class="p">,</span> <span class="n">defaults</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Process data-carrier overrides</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">ReducerMap</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">overrides</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_arg_values</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">ReducerMap</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Override `</span><span class="si">%s</span><span class="s2">` is incompatible with overrides `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">overrides</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]))</span>
        <span class="c1"># Process data-carrier defaults</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="c1"># E.g., SubFunctions</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">_arg_values</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Default `</span><span class="si">%s</span><span class="s2">` is incompatible with other args as &quot;</span>
                                     <span class="s2">&quot;`</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">`, while `</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">` is expected. Perhaps you &quot;</span>
                                     <span class="s2">&quot;forgot to override `</span><span class="si">%s</span><span class="s2">`?&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">p</span><span class="p">))</span>
                <span class="n">args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">()</span>

        <span class="c1"># All DiscreteFunctions should be defined on the same Grid</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="p">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">overrides</span><span class="p">}</span>
        <span class="n">grids</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">getattr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">})</span>
        <span class="n">grids</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;mpi&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple Grids found&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Process Dimensions</span>
        <span class="c1"># A topological sorting is used so that derived Dimensions are processed after</span>
        <span class="c1"># their parents (note that a leaf Dimension can have an arbitrary long list of</span>
        <span class="c1"># ancestors)</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                  <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Derived</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()):</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_arg_values</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dspace</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Process Objects (which may need some `args`)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">_arg_values</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Sanity check</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_arg_check</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dspace</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Derived</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">_arg_check</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dspace</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>

        <span class="c1"># Turn arguments into a format suitable for the generated code</span>
        <span class="c1"># E.g., instead of NumPy arrays for Functions, the generated code expects</span>
        <span class="c1"># pointers to ctypes.Struct</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">_arg_as_ctype</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">p</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># User-provided floats/ndarray obviously do not have `_arg_as_ctype`</span>
                <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">_arg_as_ctype</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="n">p</span><span class="p">))</span>

        <span class="c1"># Add in the profiler argument</span>
        <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># Add in any backend-specific argument</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;backend&#39;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="c1"># Execute autotuning and adjust arguments accordingly</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autotune</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;autotune&#39;</span><span class="p">,</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;autotuning&#39;</span><span class="p">]))</span>

        <span class="c1"># Check all user-provided keywords are known to the Operator</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;ignore-unknowns&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_arguments</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized argument </span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="c1"># Attach `grid` to the arguments map</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">ArgumentsMap</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">_postprocess_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process runtime arguments upon returning from ``.apply()``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_arg_apply</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_arg_apply</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_known_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The arguments that can be passed to ``apply`` when running the Operator.&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_arg_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_autotune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">setup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Auto-tuning to improve runtime performance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Operator.arguments"><a class="viewcode-back" href="../../operator.html#devito.operator.Operator.arguments">[docs]</a>    <span class="k">def</span> <span class="nf">arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Arguments to run the Operator.&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_arguments</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Check all arguments are present</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No value found for parameter </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span></div>

    <span class="c1"># JIT compilation</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_soname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A unique name for the shared object resulting from JIT compilation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Signer</span><span class="o">.</span><span class="n">_digest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JIT-compile the C code generated by the Operator.</span>

<span class="sd">        It is ensured that JIT compilation will only be performed once per</span>
<span class="sd">        Operator, reagardless of how many times this method is invoked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="o">.</span><span class="n">jit_compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soname</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ccode</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The JIT-compiled C function as a ctypes.FuncPtr object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_soname</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfunction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cfunction</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># Associate a C type to each argument for runtime type check</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cfunction</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">_C_ctype</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cfunction</span>

    <span class="c1"># Execution and profiling</span>

<div class="viewcode-block" id="Operator.apply"><a class="viewcode-back" href="../../operator.html#devito.operator.Operator.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the Operator.</span>

<span class="sd">        With no arguments provided, the Operator runs using the data carried by the</span>
<span class="sd">        objects appearing in the input expressions -- these are referred to as the</span>
<span class="sd">        &quot;default arguments&quot;.</span>

<span class="sd">        Optionally, any of the Operator default arguments may be replaced by passing</span>
<span class="sd">        suitable key-value arguments. Given ``apply(k=v, ...)``, ``(k, v)`` may be</span>
<span class="sd">        used to:</span>

<span class="sd">        * replace a Constant. In this case, ``k`` is the name of the Constant,</span>
<span class="sd">          ``v`` is either a Constant or a scalar value.</span>

<span class="sd">        * replace a Function (SparseFunction). Here, ``k`` is the name of the</span>
<span class="sd">          Function, ``v`` is either a Function or a numpy.ndarray.</span>

<span class="sd">        * alter the iteration interval along a Dimension. Consider a generic</span>
<span class="sd">          Dimension ``d`` iterated over by the Operator.  By default, the Operator</span>
<span class="sd">          runs over all iterations within the compact interval ``[d_m, d_M]``,</span>
<span class="sd">          where ``d_m`` and ``d_M`` are, respectively, the smallest and largest</span>
<span class="sd">          integers not causing out-of-bounds memory accesses (for the Grid</span>
<span class="sd">          Dimensions, this typically implies iterating over the entire physical</span>
<span class="sd">          domain). So now ``k`` can be either ``d_m`` or ``d_M``, while ``v``</span>
<span class="sd">          is an integer value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider the following Operator</span>

<span class="sd">        &gt;&gt;&gt; from devito import Eq, Grid, TimeFunction, Operator</span>
<span class="sd">        &gt;&gt;&gt; grid = Grid(shape=(3, 3))</span>
<span class="sd">        &gt;&gt;&gt; u = TimeFunction(name=&#39;u&#39;, grid=grid, save=3)</span>
<span class="sd">        &gt;&gt;&gt; op = Operator(Eq(u.forward, u + 1))</span>

<span class="sd">        The Operator is run by calling ``apply``</span>

<span class="sd">        &gt;&gt;&gt; summary = op.apply()</span>

<span class="sd">        The variable ``summary`` contains information about runtime performance.</span>
<span class="sd">        As no key-value parameters are specified, the Operator runs with its</span>
<span class="sd">        default arguments, namely ``u=u, x_m=0, x_M=2, y_m=0, y_M=2, time_m=0,</span>
<span class="sd">        time_M=1``.</span>

<span class="sd">        At this point, the same Operator can be used for a completely different</span>
<span class="sd">        run, for example</span>

<span class="sd">        &gt;&gt;&gt; u2 = TimeFunction(name=&#39;u&#39;, grid=grid, save=5)</span>
<span class="sd">        &gt;&gt;&gt; summary = op.apply(u=u2, x_m=1, y_M=1)</span>

<span class="sd">        Now, the Operator will run with a different set of arguments, namely</span>
<span class="sd">        ``u=u2, x_m=1, x_M=2, y_m=0, y_M=1, time_m=0, time_M=3``.</span>

<span class="sd">        To run an Operator that only uses buffered TimeFunctions, the maximum</span>
<span class="sd">        iteration point along the time dimension must be explicitly specified</span>
<span class="sd">        (otherwise, the Operator wouldn&#39;t know how many iterations to run).</span>

<span class="sd">        &gt;&gt;&gt; u3 = TimeFunction(name=&#39;u&#39;, grid=grid)</span>
<span class="sd">        &gt;&gt;&gt; op = Operator(Eq(u3.forward, u3 + 1))</span>
<span class="sd">        &gt;&gt;&gt; summary = op.apply(time_M=10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build the arguments list to invoke the kernel function</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Invoke kernel function with args</span>
        <span class="n">arg_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cfunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfunction</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span><span class="o">.</span><span class="n">timer_on</span><span class="p">(</span><span class="s1">&#39;apply&#39;</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">comm</span><span class="p">):</span>
                <span class="n">cfunction</span><span class="p">(</span><span class="o">*</span><span class="n">arg_values</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">ArgumentError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;argument &quot;</span><span class="p">):</span>
                <span class="n">argnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">9</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">newmsg</span> <span class="o">=</span> <span class="s2">&quot;error in argument &#39;</span><span class="si">%s</span><span class="s2">&#39; with value &#39;</span><span class="si">%s</span><span class="s2">&#39;: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">argnum</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">arg_values</span><span class="p">[</span><span class="n">argnum</span><span class="p">],</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">raise</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="n">newmsg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="c1"># Post-process runtime arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postprocess_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Output summary of performance achieved</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profile_output</span><span class="p">(</span><span class="n">args</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_profile_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a performance summary of the profiled sections.&quot;&quot;&quot;</span>
        <span class="c1"># Rounder to 2 decimal places</span>
        <span class="n">fround</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ceil</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>

        <span class="n">info</span><span class="p">(</span><span class="s2">&quot;Operator `</span><span class="si">%s</span><span class="s2">` run in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                              <span class="n">fround</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span><span class="o">.</span><span class="n">py_timers</span><span class="p">[</span><span class="s1">&#39;apply&#39;</span><span class="p">])))</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_profiler</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">,</span> <span class="n">reduce_over</span><span class="o">=</span><span class="s1">&#39;apply&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_log_enabled_for</span><span class="p">(</span><span class="s1">&#39;PERF&#39;</span><span class="p">):</span>
            <span class="c1"># Do not waste time</span>
            <span class="k">return</span> <span class="n">summary</span>

        <span class="k">if</span> <span class="n">summary</span><span class="o">.</span><span class="n">globals</span><span class="p">:</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">2</span>

            <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;Global performance indicators&quot;</span><span class="p">)</span>

            <span class="c1"># With MPI enabled, the &#39;vanilla&#39; entry contains &quot;cross-rank&quot; performance data</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">summary</span><span class="o">.</span><span class="n">globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vanilla&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gflopss</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2"> GFlops/s&quot;</span> <span class="o">%</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">gflopss</span><span class="p">)</span>
                <span class="n">gpointss</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2"> GPts/s&quot;</span> <span class="o">%</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">gpointss</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">gpointss</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">metrics</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">gflopss</span><span class="p">,</span> <span class="n">gpointss</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">* Operator `</span><span class="si">%s</span><span class="s2">` with OI=</span><span class="si">%.2f</span><span class="s2"> computed in </span><span class="si">%.2f</span><span class="s2"> s [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">oi</span><span class="p">),</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="n">metrics</span><span class="p">))</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">summary</span><span class="o">.</span><span class="n">globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fdlike&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">* Achieved </span><span class="si">%.2f</span><span class="s2"> FD-GPts/s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">gpointss</span><span class="p">))</span>

            <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;Local performance indicators&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Emit local, i.e. &quot;per-rank&quot; performance. Without MPI, this is the only</span>
        <span class="c1"># thing that will be emitted</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">summary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="s2">&quot;[rank</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="o">.</span><span class="n">rank</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">rank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">gflopss</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2"> GFlops/s&quot;</span> <span class="o">%</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">gflopss</span><span class="p">)</span>
            <span class="n">gpointss</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2"> GPts/s&quot;</span> <span class="o">%</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">gpointss</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">gpointss</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">metrics</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">gflopss</span><span class="p">,</span> <span class="n">gpointss</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">itershapes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">its</span><span class="p">)</span> <span class="k">for</span> <span class="n">its</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">itershapes</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">itershapes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span>
                                     <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itershapes</span><span class="p">))</span>
                <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">* </span><span class="si">%s</span><span class="s2"> with OI=</span><span class="si">%.2f</span><span class="s2"> computed in </span><span class="si">%.2f</span><span class="s2"> s [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">oi</span><span class="p">),</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="n">metrics</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">itershapes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">itershapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">* </span><span class="si">%s</span><span class="s2"> with OI=</span><span class="si">%.2f</span><span class="s2"> computed in </span><span class="si">%.2f</span><span class="s2"> s [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">oi</span><span class="p">),</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="n">metrics</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span>
                <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">* </span><span class="si">%s%s</span><span class="s2"> computed in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span>
                     <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">fround</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">time</span><span class="p">)))</span>

        <span class="c1"># Emit relevant configuration values</span>
        <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;Configuration:  </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">[</span><span class="s1">&#39;optimizations&#39;</span><span class="p">])</span>

        <span class="c1"># Emit relevant performance arguments</span>
        <span class="n">perf_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">is_PerfKnob</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">perf_args</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Try with the aliases</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">_arg_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                        <span class="n">perf_args</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                        <span class="k">break</span>
        <span class="n">perf</span><span class="p">(</span><span class="s2">&quot;Performance arguments:  </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">perf_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="c1"># Misc properties</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_mem_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The amount of data, in bytes, used by the Operator. This is provided as</span>
<span class="sd">        symbolic expressions, one symbolic expression for each memory scope (external,</span>
<span class="sd">        stack, heap).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">root</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_table</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">derive_parameters</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Function</span><span class="p">]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">external</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">symbolic_shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">functions</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_mem_external</span><span class="p">]</span>
        <span class="n">external</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">external</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;external&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">external</span>

        <span class="n">heap</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">symbolic_shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">functions</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_mem_heap</span><span class="p">]</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heap</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;heap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">symbolic_shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">functions</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_mem_stack</span><span class="p">]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">()</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;stack&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack</span>

        <span class="n">summary</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">external</span> <span class="o">+</span> <span class="n">heap</span> <span class="o">+</span> <span class="n">stack</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="c1"># Pickling support</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="c1"># The compiled shared-object will be pickled; upon unpickling, it</span>
            <span class="c1"># will be restored into a potentially different temporary directory,</span>
            <span class="c1"># so the entire process during which the shared-object is loaded and</span>
            <span class="c1"># given to ctypes must be performed again</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_lib&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_cfunction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Do not pickle the `args` used to construct the Operator. Not only</span>
            <span class="c1"># would this be completely useless, but it might also lead to</span>
            <span class="c1"># allocating additional memory upon unpickling, as the user-provided</span>
            <span class="c1"># equations typically carry different instances of the same Function</span>
            <span class="c1"># (e.g., f(t, x-1), f(t, x), f(t, x+1)), which are different objects</span>
            <span class="c1"># with distinct `.data` fields</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;binary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">soname</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_soname&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">binary</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># If the `sonames` don&#39;t match, there *might* be a hidden bug as the</span>
        <span class="c1"># unpickled Operator might be generating code that differs from that</span>
        <span class="c1"># generated by the pickled Operator. For example, a stupid bug that we</span>
        <span class="c1"># had to fix was due to rebuilding SymPy expressions which weren&#39;t</span>
        <span class="c1"># automatically getting the flag `evaluate=False`, thus producing x+2</span>
        <span class="c1"># on the unpickler instead of x+1+1).  However, different `sonames`</span>
        <span class="c1"># doesn&#39;t necessarily means there&#39;s a bug: if the unpickler and the</span>
        <span class="c1"># pickler are two distinct processes and the unpickler runs with a</span>
        <span class="c1"># different `configuration` dictionary, then the `sonames` might indeed</span>
        <span class="c1"># be different, depending on which entries in `configuration` differ.</span>
        <span class="k">if</span> <span class="n">soname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">soname</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_soname</span><span class="p">:</span>
                <span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The pickled and unpickled Operators have different .sonames; &quot;</span>
                        <span class="s2">&quot;this might be a bug, or simply a harmless difference in &quot;</span>
                        <span class="s2">&quot;`configuration`. You may check they produce the same code.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soname</span><span class="p">,</span> <span class="n">binary</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lib</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_soname</span></div>


<span class="c1"># Misc helpers</span>


<span class="k">class</span> <span class="nc">ArgumentsMap</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ArgumentsMap</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The MPI communicator the arguments are collective over.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">comm</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_NULL</span>


<span class="k">def</span> <span class="nf">set_dse_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;noop&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mode</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Illegal DSE mode </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">set_dle_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mode</span><span class="p">,</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mode</span><span class="p">,</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;noop&#39;</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mode</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">mode</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">)),</span> <span class="p">{}</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Illegal DLE mode </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_threaded</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">set_dle_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;openmp&#39;</span><span class="p">,</span> <span class="n">configuration</span><span class="p">[</span><span class="s1">&#39;openmp&#39;</span><span class="p">])</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Devito

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>